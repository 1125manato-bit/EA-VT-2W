/*
  ==============================================================================
    VT-2W White - EMU AUDIO
    Plugin Editor (UI) Implementation
  ==============================================================================
*/

#include "PluginEditor.h"
#include "BinaryData.h"
#include "PluginProcessor.h"
#include <iostream>

// インタラクティブモード中のresizedによる初期化を防止
static bool g_interactiveDebug = false;

//==============================================================================
// VT2WImageKnob
//==============================================================================

VT2WImageKnob::VT2WImageKnob() { setRepaintsOnMouseActivity(true); }
VT2WImageKnob::~VT2WImageKnob() {}

void VT2WImageKnob::setImage(const juce::Image &image) {
  knobImage = image;
  repaint();
}

void VT2WImageKnob::paint(juce::Graphics &g) {
  auto bounds = getLocalBounds().toFloat();
  auto centre = bounds.getCentre();

  if (knobImage.isValid()) {
    float normalizedValue =
        static_cast<float>((value - minValue) / (maxValue - minValue));
    float angle = startAngle + normalizedValue * (endAngle - startAngle);

    float knobSize = juce::jmin(bounds.getWidth(), bounds.getHeight());
    float scale = knobSize / static_cast<float>(knobImage.getWidth());

    // 円形クリッピングを適用（黒い角を非表示にする）
    juce::Path clipPath;
    clipPath.addEllipse(bounds.reduced(1.0f));
    g.reduceClipRegion(clipPath);

    juce::AffineTransform transform =
        juce::AffineTransform::rotation(
            angle, static_cast<float>(knobImage.getWidth()) / 2.0f,
            static_cast<float>(knobImage.getHeight()) / 2.0f)
            .scaled(scale)
            .translated(centre.x - (knobImage.getWidth() * scale) / 2.0f,
                        centre.y - (knobImage.getHeight() * scale) / 2.0f);

    g.drawImageTransformed(knobImage, transform, false);
  }

  if (editMode) {
    // エディットモード用の視覚効果
    g.setColour(juce::Colours::cyan.withAlpha(0.3f));
    g.fillEllipse(bounds.reduced(2.0f));
    g.setColour(juce::Colours::white);
    g.drawEllipse(bounds.reduced(2.0f), 2.0f);

    // 座標表示
    g.setColour(juce::Colours::black.withAlpha(0.7f));
    g.fillRect(0, 0, getWidth(), 35);
    g.setColour(juce::Colours::yellow);
    g.setFont(juce::Font(12.0f, juce::Font::bold));

    int centerX = getX() + getWidth() / 2;
    int centerY = getY() + getHeight() / 2;
    juce::String msg = label + " | C:" + juce::String(centerX) + "," +
                       juce::String(centerY) + " S:" + juce::String(getWidth());
    g.drawText(msg, 0, 0, getWidth(), 35, juce::Justification::centred);
  }
#endif
}

void VT2WImageKnob::resized() {}

void VT2WImageKnob::setRange(double min, double max, double interval) {
  minValue = min;
  maxValue = max;
  juce::ignoreUnused(interval);
  defaultValue = min;
}

void VT2WImageKnob::setValue(double newValue,
                             juce::NotificationType notification) {
  value = juce::jlimit(minValue, maxValue, newValue);
  repaint();
  if (notification != juce::dontSendNotification && onValueChange)
    onValueChange();
}

double VT2WImageKnob::getValue() const { return value; }

void VT2WImageKnob::setLabel(const juce::String &labelText) {
  label = labelText;
}

void VT2WImageKnob::setRotationRange(float startAngleRadians,
                                     float endAngleRadians) {
  startAngle = startAngleRadians;
  endAngle = endAngleRadians;
}

void VT2WImageKnob::mouseDown(const juce::MouseEvent &event) {
#ifdef VT2W_DEBUG_MODE
  if (editMode) {
    debugDragStartX = event.getScreenX();
    debugDragStartY = event.getScreenY();
    return;
  }
#endif

  dragStartValue = value;
  dragStartY = event.y;
}

void VT2WImageKnob::mouseDrag(const juce::MouseEvent &event) {
#ifdef VT2W_DEBUG_MODE
  if (editMode) {
    int dx = event.getScreenX() - debugDragStartX;
    int dy = event.getScreenY() - debugDragStartY;
    debugDragStartX = event.getScreenX();
    debugDragStartY = event.getScreenY();

    setTopLeftPosition(getX() + dx, getY() + dy);
    repaint();
    return;
  }
#endif

  float sensitivity = event.mods.isShiftDown() ? 0.002f : 0.01f;
  double delta = static_cast<double>(dragStartY - event.y) * sensitivity *
                 (maxValue - minValue);
  setValue(dragStartValue + delta);
}

void VT2WImageKnob::mouseUp(const juce::MouseEvent &) { debugMode = false; }
void VT2WImageKnob::mouseDoubleClick(const juce::MouseEvent &) {
  setValue(defaultValue);
}

void VT2WImageKnob::mouseWheelMove(const juce::MouseEvent &,
                                   const juce::MouseWheelDetails &wheel) {
#ifdef VT2W_DEBUG_MODE
  if (editMode) {
    int delta = (wheel.deltaY > 0) ? 1 : -1;
    int newSize = juce::jmax(10, getWidth() + delta);
    int diff = newSize - getWidth();
    // 中心を維持してサイズ変更
    setBounds(getX() - diff / 2, getY() - diff / 2, newSize, newSize);
    repaint();
    return;
  }
#endif

  double delta = wheel.deltaY * (maxValue - minValue) * 0.05;
  setValue(value + delta);
}

//==============================================================================
// VT2WWhiteEditor
//==============================================================================

VT2WWhiteEditor::VT2WWhiteEditor(VT2WWhiteProcessor &p)
    : AudioProcessorEditor(&p), audioProcessor(p) {

  loadImages();

  // ウィンドウサイズを設定
  // 背景画像に合わせて自動設定
  if (backgroundImage.isValid()) {
    setSize(backgroundImage.getWidth(), backgroundImage.getHeight());
  } else {
    setSize(800, 600); // フォールバック
  }

  // Driveノブ
  driveKnob.setImage(knobImage);
  driveKnob.setLabel("DRIVE");
  driveKnob.setRange(0.0, 100.0, 0.1);
  driveKnob.setValue(0.0);
  driveKnob.setRotationRange(-2.35619f, 2.35619f);
  addAndMakeVisible(driveKnob);

  // Mixノブ
  mixKnob.setImage(knobImage);
  mixKnob.setLabel("MIX");
  mixKnob.setRange(0.0, 100.0, 1.0);
  mixKnob.setValue(100.0);
  mixKnob.setRotationRange(-2.35619f, 2.35619f);
  addAndMakeVisible(mixKnob);

  // パラメータ連携用スライダー
  driveSlider.setRange(0.0, 10.0);
  mixSlider.setRange(0.0, 100.0);

  // バインディング
  driveKnob.onValueChange = [this]() {
    // 0-100 -> 0-10
    driveSlider.setValue(driveKnob.getValue() / 10.0,
                         juce::sendNotificationSync);
  };
  mixKnob.onValueChange = [this]() {
    mixSlider.setValue(mixKnob.getValue(), juce::sendNotificationSync);
  };

  driveSlider.onValueChange = [this]() {
    driveKnob.setValue(driveSlider.getValue() * 10.0,
                       juce::dontSendNotification);
  };
  mixSlider.onValueChange = [this]() {
    mixKnob.setValue(mixSlider.getValue(), juce::dontSendNotification);
  };

  // Attachment
  driveAttachment =
      std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(
          audioProcessor.getParameters(), "drive", driveSlider);
  mixAttachment =
      std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment>(
          audioProcessor.getParameters(), "mix", mixSlider);

  // 初期値反映
  driveKnob.setValue(driveSlider.getValue() * 10.0, juce::dontSendNotification);
  mixKnob.setValue(mixSlider.getValue(), juce::dontSendNotification);

#ifdef VT2W_DEBUG_MODE
  addAndMakeVisible(editModeButton);
  editModeButton.setButtonText("EDIT OFF");
  editModeButton.setToggleState(false, juce::dontSendNotification);
  editModeButton.onClick = [this]() { updateEditMode(); };
#endif
}

void VT2WWhiteEditor::updateEditMode() {
  isEditMode = !isEditMode;
  g_interactiveDebug = isEditMode;
  editModeButton.setButtonText(isEditMode ? "EDIT ON" : "EDIT OFF");
  editModeButton.setColour(juce::TextButton::buttonColourId,
                           isEditMode ? juce::Colours::red
                                      : juce::Colours::darkgrey);

  driveKnob.setEditMode(isEditMode);
  mixKnob.setEditMode(isEditMode);

  repaint();
}

VT2WWhiteEditor::~VT2WWhiteEditor() {
  driveAttachment.reset();
  mixAttachment.reset();
}

void VT2WWhiteEditor::loadImages() {
  // BinaryData名は CMakeLists.txt の juce_add_binary_data
  // で指定されたファイル名に基づく
  // "." は "_" に置換される。 background.jpg -> background_jpg
  backgroundImage = juce::ImageCache::getFromMemory(
      BinaryData::background_jpg, BinaryData::background_jpgSize);

  // knob.png (実際にはシステムにより透過なしJPGに変換されている可能性が高い)
  // をロード
  juce::Image rawKnob = juce::ImageCache::getFromMemory(
      BinaryData::knob_png, BinaryData::knob_pngSize);

  if (rawKnob.isValid()) {
    // 透過対応のARGB形式で新しい画像を作成
    knobImage = juce::Image(juce::Image::ARGB, rawKnob.getWidth(),
                            rawKnob.getHeight(), true);

    juce::Image::BitmapData srcData(rawKnob, juce::Image::BitmapData::readOnly);
    juce::Image::BitmapData dstData(knobImage,
                                    juce::Image::BitmapData::readWrite);

    for (int y = 0; y < rawKnob.getHeight(); ++y) {
      for (int x = 0; x < rawKnob.getWidth(); ++x) {
        juce::Colour c = srcData.getPixelColour(x, y);

        // 黒色（または非常に黒に近い色）を透明にする
        // JPEGのアーティファクトを考慮して閾値を少し上げる（32 -> 40）
        if (c.getRed() < 40 && c.getGreen() < 40 && c.getBlue() < 40) {
          dstData.setPixelColour(x, y, juce::Colours::transparentBlack);
        } else {
          dstData.setPixelColour(x, y, c.withAlpha(1.0f));
        }
      }
    }

    // ノブにセット
    driveKnob.setImage(knobImage);
    mixKnob.setImage(knobImage);
  }
}

void VT2WWhiteEditor::paint(juce::Graphics &g) {
  if (backgroundImage.isValid()) {
    g.drawImage(backgroundImage, getLocalBounds().toFloat());
  } else {
    g.fillAll(juce::Colours::white);
    g.setColour(juce::Colours::black);
    g.drawText("Background Image Not Found", getLocalBounds(),
               juce::Justification::centred);
  }

#ifdef VT2W_DEBUG_MODE
  if (isEditMode) {
    g.setColour(juce::Colours::red.withAlpha(0.2f));
    g.fillAll();
    g.setColour(juce::Colours::white);
    g.setFont(juce::Font(24.0f, juce::Font::bold));
    g.drawText("EDIT MODE: Drag to Move / Scroll to Resize", 0, 0, getWidth(),
               50, juce::Justification::centred);
  }
#endif
}

void VT2WWhiteEditor::resized() {
#ifdef VT2W_DEBUG_MODE
  editModeButton.setBounds(10, 10, 100, 30);
#endif

  if (g_interactiveDebug)
    return;

  // ユーザー指定座標(Centerで設定)
  int knobSize = 206;
  int radius = knobSize / 2;

  // DRIVE: Center(216, 523) -> TopLeft(216-103, 523-103)
  driveKnob.setBounds(216 - radius, 523 - radius, knobSize, knobSize);

  // MIX: Center(809, 523) -> TopLeft(809-103, 523-103)
  mixKnob.setBounds(809 - radius, 523 - radius, knobSize, knobSize);
}
